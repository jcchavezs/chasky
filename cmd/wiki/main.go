//go:generate go run ./main.go
package main

import (
	"bytes"
	"errors"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
)

func main() {
	err := errors.Join(
		generateWikiSection("../../internal/source", "../../wiki/Sources.md"),
		generateWikiSection("../../internal/output", "../../wiki/Outputs.md"),
	)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating docs: %v\n", err)
		os.Exit(1)
	}
}

// generateWikiSection iterates over every child directory of sourceDir in alphabetical order,
// pick up the README.md file if exists and append it's content to the outputFile
// file.
func generateWikiSection(sourceDir, outputFile string) error {
	entries, err := os.ReadDir(sourceDir)
	if err != nil {
		return fmt.Errorf("reading source directory: %w", err)
	}

	var dirs []fs.DirEntry
	for _, entry := range entries {
		if entry.IsDir() {
			dirs = append(dirs, entry)
		}
	}

	sort.Slice(dirs, func(i, j int) bool {
		return dirs[i].Name() < dirs[j].Name()
	})

	outFile, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("creating output file: %w", err)
	}
	defer func() {
		_ = outFile.Close()
	}()

	if _, err := fmt.Fprintln(outFile, "<!-- Code generated by ./cmd/wiki. DO NOT EDIT. -->"); err != nil {
		return fmt.Errorf("writing to output file: %w", err)
	}

	for _, dir := range dirs {
		readmePath := filepath.Join(sourceDir, dir.Name(), "README.md")
		content, err := os.ReadFile(readmePath)
		if err != nil {
			if os.IsNotExist(err) {
				continue
			}
			return fmt.Errorf("reading %s: %w", readmePath, err)
		}
		content = bytes.TrimSpace(content)

		if _, err := fmt.Fprintln(outFile, "\n"+string(content)); err != nil {
			return fmt.Errorf("writing to output file: %w", err)
		}
	}

	return nil
}
